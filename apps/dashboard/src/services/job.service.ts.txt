import { api } from "@/lib/rpc-client";
import { FetchHttpClient, HttpClient } from "@effect/platform";
import { RpcClient, RpcSerialization } from "@effect/rpc";
import {
  layerProtocolHttp,
  makeProtocolHttp,
  Protocol,
} from "@effect/rpc/RpcClient";
import { Job, Rpcs } from "@repo/domain";
import { Effect, Layer, Cache, Duration } from "effect";

const SERVER_URL = import.meta.env.VITE_SERVER_URL || "localhost:9090";

const ProtocolLive = RpcClient.layerProtocolHttp({
  url: `http://${SERVER_URL}/`,
}).pipe(Layer.provide([FetchHttpClient.layer, RpcSerialization.layerJson]));

class ApiClient extends Effect.Service<ApiClient>()("ApiClient", {
  effect: Effect.gen(function* () {
    const client = yield* RpcClient.make(Rpcs);
    return client;
  }).pipe(Effect.provide(ProtocolLive)),
}) {}

class JobService extends Effect.Service<JobService>()("JobService", {
  scoped: Effect.gen(function* () {
    const client = yield* ApiClient;

    const getJob = (id: number) => yield* client.job.get({ id });

    const jobCache = yield* Cache.make({
      capacity: 1500,
      lookup: getJob,
      timeToLive: Duration.hours(1),
    });

    const stream = Stream.paginateChunkEffect(
      0,
      Effect.fnUntraced(function* (offset) {
        const response = yield* pokemonClient
          .get(`/pokemon?limit=${limit}&offset=${offset}`)
          .pipe(
            Effect.andThen(
              HttpClientResponse.schemaBodyJson(PaginatedPokemonResponse),
            ),
          );

        const pokemons = yield* Effect.all(
          response.results.map((result) =>
            pokemonsCache.get(result.url.toString()),
          ),
          { concurrency: 8 },
        );

        return [
          Chunk.unsafeFromArray(pokemons),
          response.next === null ? Option.none() : Option.some(offset + limit),
        ];
      }),
    );

    return { stream } as const;
  }),
}) {}

const runtime = Atom.runtime(PokemonService.Default);

export const allPokemonsAtom = runtime
  .pull(
    Effect.fnUntraced(function* () {
      const { stream } = yield* PokemonService;
      return stream;
    }, Stream.unwrap),
  )
  .pipe(Atom.keepAlive);

